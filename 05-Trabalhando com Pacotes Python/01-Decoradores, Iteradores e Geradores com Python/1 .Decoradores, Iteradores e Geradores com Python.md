# 1 .Decoradores, Iteradores e Geradores com Python
## Sum√°rio 
- [Decoradores PT1](#1-decoradores-pt1)
- [Decoradores PT2](#2-decoradores-pt2)
- [Iteradores](#3-iteradores)
- [Geradores](#4-geradores)
- [Desafio](#5-explica√ß√£o-desafio)
- [Resolu√ß√£o Desafio](#6-resolu√ß√£o-desafio)
- [Links](#links-uteis)
---
## 1. Decoradores-PT1
### Objetivo Geral 
Conhecer os decoradores e como utiliz√°-los.  

### Recapitulando 
Fun√ß√µes em Python s√£o objetos de primeira classe. Isso significa que __as fun√ß√µes podem ser passadas e usadas como argumentos.__
__Exemplo__   
```
def dizer_oi(nome):
    return f"Oi {nome}"

def incentivar_aprender(nome):
    return f"Oi {nome}, vamos aprender Python juntos!"

def mensagem_para_thierry(funcao_mensagem):
    return funcao_mensagem("Thierry")


mensagem_para_thierry(dizer_oi)
mensagem_para_thierry(incentivar_aprender)

```
### Inner functions
√â poss√≠vel definir fun√ß√µes dentro de outras fun√ß√µes. Tais fun√ß√µes s√£o chamadas de fun√ß√µes internas.  
```
def pai():
    print("Escrevendo da pai() fun√ß√£o")

    def filho1():
        print("Escrevendo da filho1() fun√ß√£o")
    
    def filho2():
        print("Escrevendo da filho2() fun√ß√£o")

    filho1()
    filho2()

pai()
```
### Retornando fun√ß√µes de fun√ß√µes 
Python tamb√©m permite que voc√™ use fun√ß√µes como valores de retorno. 
```
def calcular(operacao):
    def somar(a,b):
        return a+b
    def substrair(a,b):
        return a-b
    
    if operacao == "+":
        return somar
    else:
        return substrair

resultado = calcular("+")(1,3)

print(resultado)
```
### Decoradores simples 
Agora que entendemos que fun√ß√µes s√£o como qualquer outro objeto em Python, podemos seguir em frente e ver a m√°gica que √© o decorador Python.  
__Exemplo__  
```
def meu_decorador(funcao):
    def envelope():
        print("Faz algo antes de executar a fun√ß√£o ")
        funcao()
        print("Faz algo depois de executar a fun√ß√£o ")
    return envelope

def ola_mundo():
    print("Ol√° mundo !")


ola_mundo = meu_decorador(ola_mundo)
ola_mundo()

```
__A√ßucar Sint√°tico!__  
O python permite que voc√™ use decoradores de maneira mais simples com o s√≠mbolo @.
```
def meu_decorador(funcao):
    def envelope():
        print("Faz algo antes de executar a fun√ß√£o ")
        funcao()
        print("Faz algo depois de executar a fun√ß√£o ")
    return envelope

@meu_decorador
def ola_mundo():
    print("Ol√° mundo !")


ola_mundo()
```
---
## 2. Decoradores-PT2
### Fun√ß√µes de decora√ß√£o com argumentos
Podemos usar *args e **kwargs na fun√ß√£o interna, com isso ela aceitar√° um n√∫mero arbit√°rio de argumentos posicionais e de palavras-chaves. 
```
def duplicar(func):
    def envelope(*args, **kwargs):
        func(*args,**kwargs)
        func(*args,**kwargs)

    return envelope

@duplicar
def aprender(tecnologia):
    print(f"Estou aprendendo {tecnologia}")

aprender("Pyhon")

```
Como essa utiliza√ß√£o de *arg ou **kwargs, torna a chamada da fun√ß√£o decorada mais "simples" pelo fato de escalabilidade de passagem de par√¢metro.  

### Retornando valores de fun√ß√µes decoradas 
O decorador pode decidir se retorna o valor da fun√ß√£o decorada ou n√£o. Para que o valor seja retornado a fun√ß√£o de envelope deve retornar o valor da fun√ß√£o decorada. 
```
    def envelope(*args,**kwargs):
        print("Faz algo antes de executar a fun√ß√£o ")
        resulta = funcao(*args,**kwargs)
        print("Faz algo depois de executar a fun√ß√£o ")
        return resulta
    return envelope

@meu_decorador
def ola_mundo(nome):
    print(f"Ol√° mundo !{nome}")
    return nome.upper()


# ola_mundo = meu_decorador(ola_mundo)
resultado = ola_mundo("Thierry")
print(resultado)

```
### Introspec√ß√£o 
Introspec√ß√£o √© a capacidade de um objeto saber sobre seus pr√≥prios atributos em tempo de execu√ß√£o. 
```
import functools
def meu_decorador(funcao):
    @functools.wraps(funcao)
    def envelope(*args,**kwargs):
        funcao(*args,**kwargs)
    return envelope

@meu_decorador
def ola_mundo(nome):
    print(f"Ol√° mundo !{nome}")


print(ola_mundo.__name__)

```
---
## 3. Iteradores
### Objetivo Geral 
Vamos aprender sobre iteradores e geradores em Python. Esses s√£o conceitos poderosos que nos permitem trabalhar com sequ√™ncias de maneira eficiente.   
#### Introdu√ß√£o 
Em python, um iterador √© um objeto que cont√©m um n√∫mero cont√°vel de valores que podem ser iterados, o que significa que voc√™ pode percorrer todos valores. O protocolo do iterador √© um maneira do Python fazer a itera√ß√£o de um objeto, que consiste em dois m√©todos especiais `__iter__()` e `__next__()`
E para quais s√£o os exemplos de utiliza√ß√£o de iteradores?  
__Ler arquivos grandes__  
- Economizar mem√≥ria evitando carregar todas as linhas do arquivo. 
- Iterar linha a linha do arquivo. 
```
class FileIterator:
    def __init__(self,filename):
        self.file = open(filename)

    def __iter__(self):
        return self
    
    def __next__(self):
        line = self.file.readline()
        if line != '':
            return line
        else:
            self.file.close()
            raise StopIteration
# Uso do FileIterator
for line in FileIterator('large_file.txt'):
    print(line)

```
Para utilizar √© necess√°rio utilizar 2 m√©todos, sendo o `__iter__` e 
o `__next__` quando se tem esses 2 m√©todos pode ser considerado como um iterador.
No m√©todo `__iter__` ele ir√° devolver qual √© a inst√¢ncia do objeto a ser iterado. J√° no m√©todo m√©todo `__next__` ir√° tratar os valores propriamente dito.  
__Outro Exemplo:__  
```
class MeuIterador:
    def __init__(self, numeros:list[int]):
        self.numeros = numeros
        self.contador = 0

    def __iter__(self):
        return self
    
    def __next__(self):
        try:
            numero = self.numeros[self.contador]
            self.contador += 1
            return numero * 2
        except IndexError:
            raise StopIteration

for i in MeuIterador(numeros=[1,2,3]):
    print(i)
```
---
## 4. Geradores
### O que s√£o geradores ?
S√£o tipos especiais de iteradores, ao contr√°rio das listas ou outros iter√°veis, n√£o armazenam todos os seus valores na mem√≥ria.  
S√£o definidos usando fun√ß√µes regulares, mas, ao inv√©s de retornar valores usando "return", utilizam "yield".  
### Caracter√≠sticas de geradores
- Uma vez que um item gerado √© consumida, ele √© esquecido e n√£o pode ser acessado novamente. 
- O estado interno de um gerador √© mantido entre chamadas. 
- A execu√ß√£o de um gerador √© pausada na declara√ß√£o "yield" e retomada da√≠ na pr√≥xima vez que ele for chamado.  
__Recuperando dados de uma API.__  
- Solicitar dados por p√°ginas (pagina√ß√£o). 
- Fornecer um produto por vez entre as chamadas. 
- Quando todos os produtos de uma p√°gina forem retornados, verificar se existem novas p√°ginas. 
- Tratar o consumo da API como uma lista Python . 
```
import requests

def fetch_products(api_url, max_pages=100):
    page = 1
    while page <= max_pages:
        response = requests.get(f"{api_url}?page={page}")
        data = response.json()
        for product in data['products']:
            yield product
        if 'next_page' not in data:
            break
        page += 1

for product in fetch_products("https://api.example.com/products"):
    print(product['name']) 

```
__E quando usar um gerador e quando usar o iterador ?__  
Em vias de regra sempre utilizaremos o gerador quando o seu c√≥digo for simples, ou o problema a ser resolvido for simples. Por√©m quando o desafio e um pouco mais complexo, exemplo √© preciso montar uma estrutura de dados, uma arvore bin√°ria, ai nesse momento ser√° utilizado o iterador.   

--- 
## 5. Explica√ß√£o Desafio
### Introdu√ß√£o 
Como os novos conhecimentos adquiridos sobre decoradores, geradores e iteradores, voc√™ foi encarregado de implementar as seguintes funcionalidades no sistema:  
- Decorador de log 
- Gerador de relat√≥rios 
- Iterador personalizado 
### 5.1 Decorador de log 
Implemente um decorador que seja aplicado a todas as fun√ß√µes de transa√ß√µes(Dep√≥sito, saque, cria√ß√£o de conta, etc). 
Esse decorador deve registrar(printar) a data e hora de cada transa√ß√£o, bem como o tipo de transa√ß√£o.  
[Como recuperar a data atual em Python](https://docs.python.org/pt-br/3/library/datetime.html)
### 5.2 Gerador de relat√≥rios 
Crie um gerador que permita iterar sobre as transa√ß√µes de uma conta e retorne, uma a uma, as transa√ß√µes que foram realizadas. Esse gerador deve tamb√©m ter uma forma de filtrar as transa√ß√µes baseado em seu tipo(por exemplo, apenas saques ou apenas dep√≥sitos).
### 5.3 Iterador personalizado 
Implemente um iterador personalizado ContaIterador que permita iterar sobre todas as contas do banco, retornando informa√ß√µes b√°sicas de cada conta(n√∫mero, saldo atual, etc.)

---
## 6. Materiais Complementares
Nossos materiais complementares e de apoio t√™m como objetivo apresentar informa√ß√µes para facilitar e enriquecer a sua jornada de aprendizado. Para isso, links √∫teis (como slides, reposit√≥rios e p√°ginas oficiais) ser√£o disponibilizados, al√©m de dicas sobre como se destacar na DIO e no mercado de trabalho üòâ

### Dicas/Links √öteis
Por fim, disponibilizamos alguns links √∫teis para que voc√™ possa se desenvolver ainda mais atrav√©s de refer√™ncias oficiais das tecnologias, p√°ginas de documenta√ß√£o e/ou f√≥runs de discuss√£o relevantes. Nesse contexto, seguem algumas sugest√µes:

Artigos/F√≥rum: voc√™ pode compartilhar conte√∫dos t√©cnicos atrav√©s de Artigos (vis√≠veis globalmente na plataforma da DIO). Por outro lado, voc√™ tamb√©m pode compartilhar suas conquistas e d√∫vidas usando os F√≥runs (que s√£o espec√≠ficos para cada experi√™ncia educacional na DIO, como um Bootcamp por exemplo);
Rooms: caso voc√™ esteja inscrito(a) em uma experi√™ncia educacional na DIO (como um Bootcamp, por exemplo) voc√™ ter√° acesso ao Rooms. O Rooms √© uma ferramenta de bate-papo em tempo real onde todos os inscritos podem interagir, compartilhando d√∫vidas e dicas (que podem conter imagens e snippets de c√≥digo-fonte);
Pesquise na Web: pode parecer √≥bvio, mas √© importante frisar a import√¢ncia das engines de busca no dia-a-dia de um profissional de TI. Caso n√£o encontre o que procura dentro da DIO, pesquise sobre o assunto (conceito, d√∫vida, erro etc) na Internet (d√™ um Google), pois na maioria das vezes voc√™ ser√° levado √† p√°ginas incr√≠veis como o StackOverflow que salvar√£o o seu dia üòé  

---
### Links Uteis
- [Trilha Git](https://github.com/digitalinnovationone/trilha-python-dio)

---
As respostas da aula 1 est√£o [aqui](IMGS)

---
Titulo: 1 .Decoradores, Iteradores e Geradores com Python 

Autor: Thierry Lucas Chaves

Data criacao: 08/07/2025

Data modificacao: 10/07/2025

Versao: 1.0  

---