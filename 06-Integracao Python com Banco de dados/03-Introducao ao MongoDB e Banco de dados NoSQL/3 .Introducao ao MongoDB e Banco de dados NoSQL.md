# 3 .Introducao ao MongoDB e Banco de dados NoSQL
## Sumário 
- [Introdução ao NoSQL](#1-introdução-ao-nosql)
  - [Apresentação do curso](#11-apresentação-do-curso)
  - [Apresentação](#12-apresentação)
- [Conhecendo tipos do BDNSQL](#2-conhecendo-os-tipos-de-banco-de-dodos-nosql)
  - [Tipos de Nosql](#21-tipos-de-banco-nosql)
  - [Grafos](#22-grafos)
  - [Colunar](#23-coluna-família-de-colunas)
    - [Terminologia](#231-diferenças-terminológicas)
  - [Chave Valor](#24-chave-valor)
  - [Documento](#25-documento)
- [Introdução e Instalação MongoDB](#3-introdução-e-instalação-ao-mongodb)
  - [Introdução MongoDB](#31-introdução-ao-mongodb)
    - [Analogias Mongo SQL](#311-analogias-do-mongodb-x-sql)
    - [Quando utilizar ou Não MongoDB](#312-quando-utilizar-ou-não-o-mongodb)
  - [Instalação MOngoDB](#32-instalação)
  - [MongoDB Cloud](#33-mongodb-cloud)
- [Schema Design e B.P](#4-schema-design-e-boas-práticas)
  - [Schema Design](#41-schema-design)
    - [Referência e Embedding](#411-embedding-vs-referência)
    - [Embedding](#412-embedding)
    - [Referência](#413-referência)
    - [Recomendações de uso](#414-recomendações-de-uso)
  - [Boas Práticas](#42-boas-práticas)
  - [Json x Bson](#43-json-vs-bson)
- [Conceito na prática](#5-alguns-conceitos-na-prática)
  - [Operações de manipulação](#51-operações-de-manipulação-de-dados)
  - [Performance e índices](#52-performance-e-índices)
  - [Agregações](#53-agregações)
    - [O que é agregação](#531-oque-é-agregação)
    - [Tipos de agregação](#532-tipos-de-agragação)
      - [Agragação de posposito único](#5321-agregações-de-proposito-único)
        - [Count](#53211-count)
        -[](#53212-distinct)
      -[Agregação de pipeline](#5322-agregações-de-proposito-customizadas-ou-pipeline)
        - [group](#53221-group)
        - [addFields](#53222-addfields)
    - [Funções de agregação](#533-funções-de-agregação)
      - [SUM](#5331-sum)
      - [MAX](#5332-max)
      - [MIN](#5333-min)
      - [AVG](#5334-avg)
    - [Operadores lógicios](#534-operadores-lógicos)
      - [Filtros de operadores](#5341-operadores-lógicos-com-filtros)
    - [Operadores de comparação](#535-operadores-de-comparação)

        

---
## 1. Introdução ao NOSQL
### 1.1 Apresentação do Curso
__Objetivo do curso__  
Introdução ao mundo do NoSQL, apresentar os tipos de bancos NoSQL assim como realizar pequenas operações em alguns deles com enfase no MongoDB no qual iremos desde sua instalação, opções de uso na nuvem e operações de manipulação de dados.

### 1.2 Apresentação 
#### 1.2.1  Objetivos do curso 
- Entender os fatores que levaram a criação dos bancos NoSQL. 
- Conhecer as principais diferenças gerais entre os BD SQL e NoSQL.
- Conhecer as características e vantagens do uso do BD NoSQL.

<table style="text-align: center; width: 100%;"> 
<tr>
    <td style="text-align: center;">
    <img src="imgs/NEO4J_IMGS/TL_BD.png" alt="time_line_bds" width="40%"/>
    </td>
</tr>
</table>

| | | |
| -- | -- | -- |
| N**ot**  | | **NO** |
| O**nly**| X |
| SQL | | **SQL** |

Diferenças entre BD Relacionais e BD NoSQL  
__Escalabilidade:__  Banco de dados **relacional** Vertical 
- Aumento da capacidade para um único recurso 
- Processador, memoria e disco rígido.
---
__Escalabilidade:__  Banco de dados **relacional** Horizontal 
- Replicas de dados __APENAS PARA LEITURA__    
--- 
__Escalabilidade__ Banco de dadoS **NoSQL** Horizontal 
- Particionando os dados (sharding) entre os nós é o mais conhecido.    

Sendo listado abaixo o maior beneficio da escalabilidade horizontal, presente nos Banco de dados Não relacionais.
1. Maior desempenho na aplicação. (Aperfeiçoando de acordo com a demanda, tendo uma escalabilidade "infinita")

Outra diferença de um BDR(Banco de dados relacional), para um Nosql,se da nos ditos Schemas de um BDR, nesse modelo de banco de dados temos um processo mais engessado, de todo processo conforme imagem abaixo.   

<table style="text-align: center; width: 100%;"> 
<tr>
    <td style="text-align: center;">
    <img src="imgs/NEO4J_IMGS/SchemaDBR.png" alt="Scheamas_DBS" width="40%"/>
    </td>
</tr>
</table>

Já esse processo de Schema não se tem esse processo, podendo ter uma ausência quase que completa desse tipo de  regas de Schemas, ou seja não precisa definir no ato de criação do banco quais serão os tipos de dados a serem aceitos/inseridos naquelas tabelas. 

Outra diferença que aqui pode ser citada, e o caso de performance , em um BDR depende-se inteiramente da performance do tipo de disco que aquele banco está "alocado", em um Nosql ele dependerá mais do tamanho do cluster e da latência de rede.
No que se refere as diferenças de transações, segue a lista de comparativos 

| |Transações | |
| -- | -- | -- |
| BD Relacional | | BD NoSQL |
| **A**tomicidade | | **Ba**sically Available |
| **C**onsistência | | **S**oft-State |
| **I**solamento | | **E**ventually Consistent |
| **D**urabilidade | |  |

Das características e vantagens, são elas:
- Flexibilidade
- Escalabilidade
- Alta performance.

---
## 2. Conhecendo os tipos de banco de dodos NoSQL
### 2.1 Tipos de banco Nosql
<table style="text-align: center; width: 100%;"> 
<tr>
    <td style="text-align: center;">
    <img src="imgs/NEO4J_IMGS/ranking_dbs.png" alt="ranking_nosql_grafos" width="40%"/>
    </td>
</tr>
<tr>
    <td style="text-align: center;">
    <img src="imgs/NEO4J_IMGS/tipos_NOSQL.png" alt="tipos_bancos_nosql" width="40%"/>
    </td>
</tr>
</table>

### 2.2 Grafos

<table style="text-align: center; width: 100%;"> 
<tr>
    <td style="text-align: center;">
    <img src="imgs/NEO4J_IMGS/banco_tipo_grafos.png" alt="BANCO_DO_TIPO_GRAFOS" width="40%"/>
    </td>
</tr>
</table>

Grafos basicamente são estruturas matemáticas, que são compostas de nós e seus vértices, ao se abstrair isso para o mundo do banco de dados temos os nós que serão como os nossos dados, e os vértices serão os relacionamentos. Nesse modelo é muito comum para detecção de fraudes, mecanismos de recomendações, redes sociais, sistemas de arquivos, jogos etc... ao se consultas no ranking de banco de dados olhando para os banco do tipo de grafos temos o `Neo4j` como top 1 dos mais utilizados. 
Para a prática desse tipo de banco de dados iremos criar uma estrutura de registros que compões os dados de uma rede social utilizando um `sandbox do Neo4J`. É valido ressaltar que o `Neo4J` é um dos poucos banco de dados NoSQL que aplica as propriedades `ACID`,para além de também ter um bom desempenho no quesito de concorrência de transação, e outro ponto que é valido ressaltar, e que sua linguagem é conhecida como Cypher. 
Para tal processo foi utilizado um [sandbox do Neo4j](https://sandbox.neo4j.com/)   
Dentro do banco de dados foi criando uma label conforme comando abaixo. 
```cypher
CREATE(:Client {name: "Bob Esponja", age: 28, hobbies:['Caçar agua-viva','Comer hamburgueres']})
```
Após a criação desse label/nó podemos utilizar o comando de `match`que seria uma especie de select para o Neo4j, conforme abaixo:
```cypher
match (bob_espoja) return bob_espoja
```
O comando abaixo, demonstrar algumas características do Neo4j, sendo um banco de dados NoSQL, o Neo4j aplica também o conceito de Schema-free, ou seja não é necessário realizar o insert de todos os dados para algum nó mesmo que esse aplique-se a um label. Outro ponto , que podemos ver é que é possível também já aplicar o relacionamento entre nós com utilização de labels, e isso poderá ser feito diretamente no ato da criação de um nó, no comando abaixo, criamos um nó para cliente, e mais um para adicionar um relacionamento entre cliente e bloqueado que no caso esta sendo apontado tal relacionamento com `-[]->`, após o fechamento do `()` do primeiro nó
```cypher
CREATE (:Client{name:"Lula Molusco", age:30, hobbies:['Tocar clarinete']}) -[:Bloqueado]->(:Client{name:'Patrick Estela', hobbies:['Caçar agua-viva']})
```
Ao realizar o `MATCH`, podemos visualizar de forma gráfica os relacionamentos e nós existentes no banco  

<table style="text-align: center; width: 100%;"> 
<tr>
    <td style="text-align: center;">
    <img src="imgs/NEO4J_IMGS/nos_Neo4j.png" alt="Nos_Neo4j" width="40%"/>
    </td>
</tr>
</table>

Já para criar um relacionamento entre nós já existentes podemos realizar o seguinte comando, seguindo a estrutura MATCH (*A variável na qual é desejado a atribuição do Match*), similarmente a um processo de atribuição de variável. 
```cypher
MATCH (bob:Client{name:"Bob Esponja"}), (patrick:Client{name:'Patrick Estela'}) CREATE (bob)-[:Amigo]->(patrick)
```
O comando acima listado, obedece a seguinte estrutura. No bloco do `Match` estamos criando duas *"variáveis"* bob e patrick  e realizando a busca com o MATCH, no label de cliente nós que tenham em sua propriedade `name` os nomes, Bob Esponja e Patrick Estrela, após a busca e atribuição de variáveis com esse bloco, estamos criando um relacionamento entre elas com o bloco `CREATE` , onde estamos dizendo que bob é amigo de patrick, a relação de direcionamento é definida através do sentido da *"seta"* `< >` onde nesse caso exemplificado estou aponto de bob para patrick `->`.  
Agora para exclusão de um relacionamentos podemos utilizar a seguinte sintaxe:
```cypher
MATCH (patrick:Client{name:'Lula Molusco'})-[relacionamento:Bloqueado]->() DELETE relacionamento
```
Assim como foi realizado para criar um novo relacionamento a partir de um já existente, foi realizado também para a deleção de um relacionamento a utilização de um `Match`, porém o restante do comando diverge, após a busca e atribuição vemos que temos a abertura de um processo de relacionamento, seguido de uma variável e qual é a label utilizada,  e posteriormente qual será esse relacionamento apagado, onde informamos através de no nó anonimo `()`, que serão apagados todos os relacionamentos que tenham essa label, em seguida o comando recebe o comando DELETE e o que quero deletar que no caso é que existe para variável nomeada de relacionamento.  
Já para exclusão de um nó podemos, utilizar a mesma estrutura do comando para apagar o relacionamento, porém se a adição das condições de relacionamento conforme exemplo abaixo:
```cypher
MATCH (lula:Client{name:"Lula Molusco"}) DELETE lula
```
Já para atualizar um dado, propriedades para um nó existente, seguimos a ideia de atualização com base no retorno de um `MATCH`, porém a diferenciação do delete ou create o comando para atualizar algo em um nó é SET, após esse comando utilizamos a variável encontrada, e dizemos o que dentro da estrutura por exemplo do label o que vamos atualizar. 
```cypher
MATCH (patrick:Client {name:'Patrick Estela'}) SET patrick.age = 23;
```
Ainda na linha de atualização também podemos atualizar um label, para tal ao invés de atribuir a variável uma nova propriedade dentro de uma  label já existente , inserimos a sintaxe `SET variavel:Nome da nova label`.

---
### 2.3 Coluna-Família de colunas

<table style="text-align: center; width: 100%;"> 
<tr>
    <td style="text-align: center;">
    <img src="imgs/Cassandra_IMGS/NOSQL_COLUNA.png" alt="columns_nosq" width="40%"/>
    </td>
</tr>
</table>

Os banco de dados colunares tem uma forma de armazenamento diferente, ao contrário dos banco de dados relacionais tradicionais, que armazenam seus dados em uma única tabela, no bancos de dado NoSQL baseados em colunas, o seu armazenamento é realizado conforme o próprio nome sugere, em suas colunas, com suas informações diferentes entre elas.   
Já no banco de dados colunares um ponto que se é valido ressaltar a diferença trata-se da **hierarquia**, a sua distribuição e armazenamento e feito dentro do que é chamado de `keyspace`, dentro desse keyspace teremos uma família de colunas, sendo essa dita família de colunas similar ao que são as tabelas em banco de dados relacionais. ou seja dentro de cada keyspace teremos as informações agregadas em colunas, porém a coluna em si diferentemente do banco de dados relacional, não é constituída apenas do valor, essa coluna é constituída de 3 informações:
1. Chave da coluna, 
2. O valor da coluna. 
3. E o timestamp  
Outro ponto que é valido se ressaltar, e que em um banco de dados do tipo coluna, somente será armazenado em memoria algo que tenha informação.   

<table style="text-align: center; width: 100%;"> 
<tr>
    <td style="text-align: center;">
    <img src="imgs/Cassandra_IMGS/ranking_dbs_colunas.png" alt="Rankings_column_database" width="30%"/>
    </td>
</tr>
</table> 

Durante o estudo utilizaremos o banco de dados `Cassandra`, e é valido ressaltar que sua utilização e recomenda em cenários que temos um volume de leitura maior do que o de escrita, e seu uso tido como adequado e quando se tem a necessidade de realizar as consultas através da chave-primária.
#### 2.3.1 Diferenças terminológicas 
- __Keyspace:__ Agrupamento de famílias de colunas => Databases.
- __Column Family/Table:__ Agrupamento de colunas => table.
- __Row key:__ Chave que representa uma linha de coluna => Primary Key.
- __Column:__ Representa um valor contendo: Name, Value e Timestamp.  
- __Registro de transações:__  Compras, resultados de testes, filmes assistidos e localização mais recente do filme. Rastreando praticamente qualquer coisa, incluindo status do pedido de pacotes etc..
Outro ponto a ser considerado durante a utilização do banco de dados `Cassandra`, e que ele é um banco com ausência total de transações, e isso deve ser levado em consideração para sua escolha.   
Para se criar um `keyspace` utilizamos o seguinte comando. 
```cql
CREATE KEYSPACE NAME_KEYSPACE WITH replication = {'class': 'SimpleStrategy', 'replication_factory' : 1};
```
Conforme demonstrado no comando acima, diferentemente da criação de um `DATABASE` em um banco de dados SQL, no cassandra precisamos além das palavras reservadas, CREATE KEYSPACE, também temos que passar como instrução alguns argumentos de replicação daquele keyspace, através do trecho `WITH replication`, onde após tal comando passamos alguns valores com notação Json, no exemplo supracitado, passamos qual a classe que esse keyspace pertence, e posteriormente o fator de replicação. 
Para utilizar esse keyspace criando assim como em um banco SQL, utilizamos o comando:  
```cql
USE NAME_KEYSPACE
```
Para se criar um família de colunas, utilizamos a seguinte sintaxe:
```cql
CREATE COLUMNFAMILY NAME_COLUMN (name TEXT PRIMARY KEY, age int)
```
Assim como em `SQL` também definimos o Schema utilizado para essa column family ou seja, quais serão os valores e seus tipos. 
Já para realizar um consulta dentro do Cassandra, a sintaxe de uma consulta básica é a mesma. 
```cql
SELECT * FROM NAME_COLUMN;
```
O mesmo é valido para a inserção de dados nessa coluna, conforme demonstrado em comando abaixo:
```cql
INSERT INTO NAME_COLUMN (name, age) values ('Bob Esponja', 38);
```
Porém no `CQL` também temos a possibilidade de inserção de dados através de um arquivo `JSON`, para tal a sintaxe do comando é a seguinte:
```cql
INSERT INTO NAME_COLUMN JSON '{"name":"Patrick"}';

```
A diferenciação desse tipo de inserção da-se primariamente pela palavra reservada `JSON`, onde é sinalizado ao Cassandra que os valores a serem inseridos nesse banco serão obtidos através de dados em formato JSON.  
Um ponto a ser notado dentro do CASSANDRA é que por mais que no ato de um select quando não há valores dentro de uma coluna, como no caso a inserção do da linha do comando acima, não foi passado a coluna o valor de age, porém ao se realizar o comando: 
```cql
SELECT age, WRITETIME(age) from NAME_COLUMN;
```
Na segunda linha que seria correspondente ao "atributo" age de patrick será retornado null em ambos, pois no banco de dados Cassandra ele não aloca espaço em disco para registros nulos. 
Para se realizar filtros ou condições de busca no cassandra o comando utilizado assim como no SQL, também é o comando `WHERE`.
Outro ponto de diferenciação de comandos do cassandra é que conseguimos durante o *SELECT* que a consulta em questão sejá retornada em forma de `JSON`, para que isso seja executado utilizamos o seguinte comanado:  
```cql
SELECT JSON  * FROM NAME_COLUMN;
```
Para atualizar registros dentro do cassandra o comando é igual a de um SQL, seguindo a seguinte sintaxe:
```cql
update name_column
set age = 2 
where name = 'Patrick';
```
O mesmo se aplica para alteração de uma CollumFamily, a sintexe para adição de uma nova coluna se da na seguinte forma:
```cql
ALTER COLUMNFAMILY NAME_COLUM  add hobby text;
```
Após algumas inserções podemos ver também uma grande difenreça entre os tipos de bancos de dados, pois caso atualizarmos 2 columas mesmo que no mesmo comando, cada atualização tera um writetime diferente, o que reforça a ideia que as colunas das coleções são independentes, 
exemplo 
```cql
update cliente
set hobby = 'caçar agua vida' where name = 'Patrick';

select age, WRITETIME(age), hobby,  WRITETIME(hobby) where neme = 'Patrick';
```
Iremos visulizar valores diferentes no WRITETIME de age e hobby. 
Para deletar um registro no Cassandra o comando se igua-la o do sql também seguindo a sintaxe:
```cql
DELETE from cliente WHERE name = 'Bob Esponja';
```
---
### 2.4 Chave-valor

<table style="text-align: center; width: 100%;"> 
<tr>
    <td style="text-align: center;">
    <img src="imgs/chave_valor_IMGS/Example_KeyValue.png" alt="reg_key_value_example" width="40%"/>
    </td>
</tr>
</table> 

O modelo  de banco de dados chave-valor, assim como o nome pressupõe é constituido por duas partes, sendo a chave (tendo que ser única para cada registro), e o valor correspondente a aquela linha.  
O banco de dados desse modelo, pode armazenar um conjunto de dados, seja ele simples ou complexo, identificados por um identificador exclusivo. 
Tem como um de seus beneficios o **bom desempenho em aplicações em nuvem** , porém **sua capacidade de busca é inferior ou menor** em relação aos demais. No que tange ao seu uso ele é bastante utilizado nos cenários de : armazenamento de cache, sessão de usuários, carrinhos de compra.  

<table style="text-align: center; width: 100%;"> 
<tr>
    <td style="text-align: center;">
    <img src="imgs/chave_valor_IMGS/ranking_dbs_keyvalue.png" alt="rank_keyvalue" width="40%"/>
    </td>
</tr>
</table> 

Para a prática e exemplos dessa aula utilizaremos o banco de dados Redis,entre suas utilizações podemos destacar o uso em : cache, messageria e fila.
- Alto desempenho. 
- Estrutura de dados na memória. 
- Versatilidade de uso. 
- Replicação e persistência. 

Para tal utilizaremos um site para exemplificação sendo ele : [try-redis](https://try.redis.io/).  
Um ponto a ser salientado e que dentro de um banco de dados Key Value, não possuimos o conceito de Schema, como o mesmo é feito de maneira de chave valor como próprio nome diz, este conceito não se aplica.  
**OBS:** Durante a aula não foram repassados comandos de criação de banco de dados somente comandos de manipulação de dados.
Para criar uma propriedade ou inserção de valor, usamos o comando descrito abaixo, porém antes da exemplificação propriamente dito, é sempre valido ressaltar que como definição desse tipo de banco de dados, 
__Não é possível realizar a busca de informações através de seu valor, por tal motivo e suma importância que se tenha o conhecimento da chave__  
```redis 
SET user1: name "Bob Esponja"
```
Já para realizar a consulta de informações dentro do banco, utilizamos a seguinte sintaxe:
```redis
GET user1:name
```
Conforme já descrito anteriormente, não é possível relaizar buscas pelo valor, essa busca é feita através de sua chave.  
Pelo fato do `Redis` não possuir uma definição de Schema mesmo em tempo de criação, ele aceita qualquer valor, o que permite por exmeplo inserção de valores em formato de JSON por exemplo:
```redis
SET user '{"name": "Patrick", "age": 31}'
```
Quando recuperado tal informação teremos uma saída em formato de JSON
```redis
GET user
```
```bash
"{\"name\": \"Patrick\", \"age\": 31}"
```
Dentro do redis, temos ainda no ambito de criação dos registros, um recurso de tempo de expiração de uma chave o que faz com que ele seja muito utilizado para armazenamento de cash e sessões de usarios, tendo duas propriedades para tal sendo elas:
- ex  = Que irá determinar em quantos segundos, aquele registro irá expirar. 
- px  = Que irpa determinar em quantos milesegundos, aquele registro irá expirar.  
```redis
SET user2: name "Lula Molusco" EX 10
```
Outro comando que pode ser citado é o `EXISTS`, com esse comando seguido da chave desejada, o redis irá retornar 0 caso aquela chave não exista mais e 1 caso contrário.  
O redis também permite a manipulação de algumas collections como por exemplo `lista` `set` e `hashset`, tendo para cada um desses tipos uma função expecifica para a a sua manipualção.   
Para se manipular uma lista temos os comandos:
- >Inserção  
```redis
LPUSH user1: hobbyes "Caçar agua-viva"
```
E impotante que após a inserção através desse método, é retornado na plataforma o valor do indice do dado que foi inserido. 
- >Consulta
```redis
LINDEX user1:hobbyes 0
```
O comando acima é utilizado para retornar um determinado valor de uma lista, já para obtenção de todos os valores da lista utilizamos o comando:  
```redis
LRANGE user1:hobbyes 01
```
Nesse comando utilizamos qual a chave está sendo procurada, e posteriomente qual o range de index a ser retornado.   

Para obter o tipo de valor utilizamos o comando `TYPE`.
Outro comando que pode ser listado aqui é o comando `TTL`, que irá retornar o tempo de expiração de uma determinada chave, para que esse retorno seja em milesegundos utilizamos `PTTL`. 
Em contra ponto ao comando de expiração, temos também o comando `PERSIST` com esse comando o tempo de expiração de um dado e removido.   
Para realizar a deleção de uma chave, para além do tempo de expiração temos o comando:
```redis 
DEL user2:name
```
Esse comando irá remover chave. 
 
----
### 2.5 Documento
<table style="text-align: center; width: 100%;"> 
<tr>
    <td style="text-align: center;">
    <img src="imgs/Documento_imgs/example_documents.png" alt="documents_example" width="40%"/>
    </td>
</tr>
</table>  

Dados e documentos autocontidos e auto descritivos, ou seja todas as informações necessárias para sua existencia estaram dentro do documento.   Permite a redundância e inconsistência, então podemos ter documentos com diferentes estruturas dentro da mesma collection.  
Livre de esquemas podendo utilizar, JSON, XML entre outros. 

<table style="text-align: center; width: 100%;"> 
<tr>
    <td style="text-align: center;">
    <img src="imgs/Documento_imgs/rankin_db_documents.png" alt="Rankings_documents_database" width="40%"/>
    </td>
</tr>
</table>  

Como restante da aula será com foco no mongo db não serão exemplificados comandos e etc.. nesse capitulo 

--- 
## 3. Introdução e Instalação ao MongoDB
### 3.1 Introdução ao MongoDB
O MongoDB é um banco de dados de código aberto, ele tem também é conhecido pela alta performance em usa utilização além de ser Schema-free, o que seguinifica que não a necessidade de definição dos tipos de dados ou algo do tipo no ato de inserção das collections, outro conceito relacionado ao MongoDB, trata-se do fato que dentro de uma collection ter a possibilidade de documentos de estruturas diferentes, o mongo utiliza arquivos um tipo de arquivo Bson que é uma "mistura de arquivos Json com binários" para o armazenamento de chave-valor, outro ponto importante sobre o MongoDB e o seu suporte a indices, em sua concepção o MongoDB foi projetado naturalmente para escalonamento horizontal conhecido como `Auto-Sharding`, também possui uma ferramenta extremamente poderosa conhecida como `Map-Reduce`, que trabalha na parte consutla e agregação, além de suportar `GridFS` que nada mais é o suporte ao armazenamento de arquivos. 
#### 3.1.1 Analogias do MongoDB x SQL

| | | 
|-- | --|
|Mongo | SQL |
|Document | Tupla/Registro | 
|Collection | Tabela | 
|Embedding/Linking | Join |

- O documento e a menor unidade de informação dentro do banco e identifica o seu registro tal qual um tupla, mesmo que o MongoDB possua suporte a ter referências a outros documentos dentro do banco, porém essa prática não deve ser implementada sem critérios muitos definidos, pois fere a ideia de um documento ser auto contido e auto descritivo, pois ao se utilizar um tipo de banco de dados como o MongoDB é preciso ter em mente que o dados não devem depender de outros dados, o que pode acarretar em redundância de dados em certo momento, porém isso não implica diretamente em um ônus de utilização. 
- Uma colllection é analogo a uma tabela em SQL, ou seja dentro de uma collection será armazenado N documentos, porém a diferença entre essas duas entidades,se da no fato que uma collection e Schema-free, pois as definições dos tipos de dados serão aplicadas diretamente aos documentos. 
- Embedding/Linking esse comando associa-se muito a um  `JOIN` em SQL, para que possamos fazer referências a outros documentos existentes no mongo porém o idel para tal utilização seria que tais documentos estejam conditos de forma Embedding, o que significa que dentro de um documento conterá a subestrutura do mesmo. 

#### 3.1.2 Quando Utilizar ou não o MongoDB
__Quando utilizar o MongoDB?__  

1. Quando se possui um grande volume de dados. 
2. Quando houver dados que não estejam necessariamente estruturados. 

__Quando NÃO utilizar o MongoDB?__   

1. Quando houver a necessidade de relacionamentos entre os dados/tabelas etc...
2. Quando algum item das propriedades **ACID** e transações de informações forem importantes.  

> Curiosidade: Diversas entidades de pagamento não homologam sistemas cujos dados financeiros dos clientes não estejam em banco de dados relacionais tradicionais. 

----
### 3.2 Instalação
Para esta aula, vamos utilizar o conceito de contêineres com Docker, gerenciando nosso ambiente com um único arquivo `docker-compose.yml`. Este documento conterá comentários explicativos, mas detalharemos as principais diretivas a seguir.

Após a instalação do Docker Desktop, vamos criar e configurar o arquivo `docker-compose.yml` com a seguinte estrutura:

```yaml
# Define a versão da sintaxe do Docker Compose
version: '3.8'

# Agrupa a definição de todos os nossos contêineres (serviços)
services:
  # O nome do nosso serviço de banco de dados
  db:
    # A imagem que será usada para criar o contêiner.
    # É uma boa prática fixar a versão para garantir a estabilidade.
    image: mongo:6.0
    
    # Nome personalizado para o contêiner, facilitando sua identificação.
    container_name: meu-mongo-db
    
    # Política de reinício: o contêiner será reiniciado automaticamente, a menos que seja parado manualmente.
    restart: unless-stopped
    
    # Mapeia a porta 27017 da máquina hospedeira para a porta 27017 do contêiner.
    ports:
      - "27017:27017"
      
    # Define as variáveis de ambiente dentro do contêiner.
    # Elas são usadas pelo script de inicialização do Mongo para criar o usuário root.
    environment:
      MONGO_INITDB_ROOT_USERNAME: ${MONGO_USER}
      MONGO_INITDB_ROOT_PASSWORD: ${MONGO_PASSWORD}
      
    # Mapeia o volume nomeado 'mongo-data' para a pasta /data/db dentro do contêiner.
    # Isso garante que os dados do banco sobrevivam mesmo que o contêiner seja removido.
    volumes:
      - mongo-data:/data/db

# Seção para declarar os volumes nomeados gerenciados pelo Docker.
volumes:
  mongo-data:
    driver: local

```
 - image: mongo:6.0  
    Como o MongoDB é amplamente utilizado, não é necessário criar uma imagem do zero (com um Dockerfile). Em vez disso, usamos uma imagem oficial e pronta do [Docker Hub](https://hub.docker.com). Adotamos a prática de fixar a versão `(ex: mongo:6.0)` para garantir que o ambiente seja estável e previsível, evitando que atualizações automáticas quebrem a aplicação no futuro.

- environment  
    Esta diretiva define variáveis de ambiente dentro do contêiner. A imagem oficial do mongo utiliza as variáveis `MONGO_INITDB_ROOT_USERNAME e MONGO_INITDB_ROOT_PASSWORD` em seu script de inicialização para configurar o primeiro usuário administrador do banco de dados. Para maior segurança, os valores dessas variáveis são lidos de um arquivo .env, que não deve ser enviado para o repositório Git.
- ports  
    A porta 27017 é a porta padrão de comunicação do MongoDB. A configuração `"27017:27017"` "expõe" a porta do contêiner, permitindo que aplicações rodando na sua máquina hospedeira se conectem ao banco de dados que está dentro do contêiner.
- volumes  
    Esta é a diretiva mais importante para a persistência de dados. Contêineres são, por design, efêmeros. Se um contêiner for removido (ex: com docker-compose down), todos os dados dentro dele são perdidos. A diretiva volumes mapeia uma pasta de dentro do contêiner (no caso, /data/db, onde o Mongo salva seus arquivos) para uma área de armazenamento gerenciada pelo Docker na sua máquina hospedeira. Dessa forma, os dados existem de forma independente do ciclo de vida do contêiner, garantindo que não sejam perdidos.

Após a configuração do `docker-compose` o mesmo será inicializado com o comando:
```bash
# O argumento -d e informado para que o terminal não seja "travado"
docker-compose up -d
```
Após subir o container, é possível visualizar se o serviço foi iniciado com o comando, que irá listar todos container ativos
```bash
docker container ps 
```
Após tal processo poderiamos realizar a conexão deste container criando com o mongo instalado localmente através de linha de comando com a seguinte sintaxe:
```bash
mongo --host localhost:27017 -p password -u user
```
onde localhost seria "trocado" pelo iplocal da máquina onde contem o mongodb, assim como password e user seriam trocados pelo usuários e senha defininos o enviroment criando no docker ou na senha diretamente definida. 
Porém caso não tenha a instalação previa do mongodb, pode ser utilizado, de uma conexão remota [client](https://robomongo.org) para tal, esse client irá diponibilizar o download do software `robomongo`, que após sua instalação, será inicializado o software propriamente dito, para que o mesmo funcione corretamente, será necessário informações como:
Nome da conexão deseja: 
tipo de conexão: standalone para o caso de estudo. 
server port obitdos no ato da criação do container, porém poderá ser localhost e a porta definida no [yaml](db/Docker/docker-compose.yaml).
Authentication 
- Authenticatio mode : basica
- User name: O nome de usuário definido no arquivo ou nas variaveis de ambiente. 
- Pssword: A senha definida no arquivo ou nas variaveis de ambiente. 
- Authentication DB: pode ser utilizado admin.
Com esses passo seguidos, poderemos utilizar o mongo db.

---
### 3.3 MongoDB Cloud
Outra alternativa para utilização do mongodb é através do [mongodb cloud](https://cloud.mongodb.com/v2/688ad8be6158e91c31a6d6cc#/overview), após o cadastro no site do mongodb, e inicialização do modo cloud, dentro da plataforma e possível criar um serviço de mongodb e utiliza-lo porém as demais aulas serão feitas via docker d Robo3t ou extensão no vscode.
---
## 4. Schema Design e Boas práticas
### 4.1 Schema Design 
#### 4.1.1 Embedding VS Referência 
Dentro do conceito de Schema Design, temos a aplicação do conceito de Embedding, e uma  das premissas desse processo trata se da ideia de __documentos autocontidos__  que nada mais é a ideia de que todas as informações que sejam necessárias para trabalhar em um documento estejam contidas no proprio documento sem que haja a necessidade de realizar quaisquer referências a outros documentos ou outra collection 
Já no processo de referência temos a ideia de __documentos com depêndencia de outros documentos ou collections__, por mais que dentro do ambiente do MongoDB não seja uma prática a utilização de referência, é possível sim encontrar em algumas literaturas artigos que tratem desse assunto, tal como se fosse um relacionamento, porém é valido ressaltar que dentro do mongodb não exista o conceito de `FK`, porém de uma certa maneira é possível ter de uma certa maneira atributos dentro dos documentos que realizarão referência a outros documentos ou collections.   

<table style="text-align: center; width: 100%;"> 
<tr>
    <td style="text-align: center;">
    <img src="imgs/MongoDB_IMGS/Schemas_design.png" alt="EmbeddingXReferencia" width="40%"/>
    </td>
</tr>
</table>  

Na imagem acima, temos os dois exemplos citados, de `Emabedding` a esqueda, na qual podemos vericar que todos os relacionamentos estão presentes, estrutura na qual também pode ser conhecida como subdocumento, e a direita temos o modelo de `Referência`, que está pode ser visualizado com a chave denominada de `parts`, que irá guardar as referências dos ID's de outros documentos.   

#### 4.1.2 Embedding
__Pros:__
- Consulta informaçlões em uma unica query
- Atualiza o registro em uma unica operação 

> OBS: Dentro do MongoDB temos o também a aplicação do conceito de Atomicidade, porém esta somente será aplicada a nível de documento. 

__Contras:__
- Limite de 16MB por documento 

#### 4.1.3 Referência
__Pros:__
- Documentos pequenos
- Não duplica informações
- (Usado quando os dados não são acessados em todas as consultas)

__COntras:__
- Duas ou mais queries ou utilização do `$lookup`

#### 4.1.4 Recomendações de uso 
- **One-to-one:** Prefira atributos chava-valor no documento
```json
{
  "_id": ObjectID(609aeec3aa1a68ca982b47d7),
  "name": "Patrick 2",
  "street": "Av das conchaas", 
  "number": 102
}
```
No exemplo acima caracteriza esse tipo de relacionamento, ou seja quando temos uma relação de informação com apenas um valor possível usamos é recomendado essa estrategia. 

- **One-to-few:** Prefira embedding
```json
{
  "_id": ObjectID(609aeec3aa1a68ca982b47d7),
  "name": "Patrick 2",
  "addresses":[
      {"street":" Av das conchas", "number": 102},
      {"street":" Rua das perolas" "number": 1000}
  ]
}
```
Esse modelo de relacionamento também pode é conhecido como `one-to-many`, nesse modelo temos que nos atinar que o crescimento deste relacionamento não será tão grande, ou seja enquanto se tiver um numero limitado de subdocumento, dentro dessa array é preferivel que essa estrutura seja utilizada. 

- **One-to-many ou Many-to-many:** Prefira referência
```json 
{
  "_id": ObjectID(609aeec3aa1a68ca982b47d7),
  "name": "Patrick 2",
  "addresses":[
              ObjectID("123"), ObjectID("1234")
  ]
}
/** Address**/
{
    "_id": ObjectID("123"),
    "street": "Av das conchaas", 
    "number": 102
}
{
    "_id": ObjectID("1234"),
    "street": "Av das conchaas", 
    "number": 102
}
``` 
O porque dessa recomendação, se da devido ao fato que quando temos um grande volume de dados na parte de relaciomentos, ficaria impraticavél a utilização da estrutura de embbeding, causando problemas na performance do documento em si. 

<table style="text-align: center; width: 100%;"> 
<tr>
    <td style="text-align: center;">
    <img src="imgs/MongoDB_IMGS/Use_case_categories.png" alt="Categorias_de_uso" width="40%"/>
    </td>
</tr>
</table>  

### 4.2 Boas práticas
- Evite documentos muito grandes
- Use nome campos objetivos e curtos
- Analise as suas queries utilizando `explain()`
- Atualize apenas os campos alterados
- Evite negações em queries.
- Listas/Arrays dentro dos documentos não podem crescer sem limite.

### 4.3 Json vs Bson
- É uma serialização codificada em binário de documentos semelhantes a `JSON`
- Contém extensções que permitem a repsentação de tipos de dados que não fazem parte da especificação `JSON`. Por exemplo, `BSON`tem um tipo Date, ObjectId.
---
## 5. Alguns conceitos na prática
### 5.1 Operações de manipulação de dados
Para o acompanhamento dessa aula foi utilizado o [container](db/Docker/) criando na [aula 3](#32-instalação), mais especificamente o processo de instalação com docker.  
Apenas para reforço de conhecimento, é valido ressaltar que o mongo segue a estrutura hierarquica da seguinte maneira:
Database  
├── Collection  
│   └── Documentos  
│     └── dados  

Para criar uma collection existem duas maneiras distintas para essa execução, sendo elas:  
1. De forma explicita, ou seja será executado o comando `db.createCollection() ` que será responsavel por essa criação
2. Seria de uma forma mais implicita, onde é digitado o nome de uma collection, deixando para que o mongo verifique a existencia dessa collection, onde casso não exista, ela será criada assim como é feito no database.  
Onde a diferença entre essas duas utilizações é quando se é criando uma collection de forma explicita, é possível passar alguns validadores para essa criação, como por exemplo: tamanho máximo do documento, tamanho máximo da collection, tamanho máximo de documentos permitidos etc..
Já da forma implicita não há esses validadores. 
Um ponto sobre a utilização de parâmetros, conforme consta no documento, quando passamos como validador por exemplo `max: 2`, informa ao mongo que dentro dessa collection, somente serão aceitos 2 documentos, porém se utilizarmos o seguinte comando 
```js
db.teste.insertOne({"name":"Teste1"});
db.teste.insertOne({"name":"Teste2"});
db.teste.insertOne({"name":"Teste3"});
``` 
Notaremos que após a 3 inserção não será retornado erro, porém o mongo substitui o expira o registro mais antigo.
[Exemplos de de criação de db's e collections](db/exemplos_criacao.js)  
Dentro deste documento temos exemplos tanto de criação de `collections` como também inserção de dados. 
#### 5.1.1 Comandos de inserção
O primeiro exemplo mostrado para inseririr um registro no MongoDB, trata-se do comando:
```js
db.name_collection.insertOne({"key":"value"});
```
Neste comando acima, que é utilizado quando vamos inserir __um único__ documento na collection, e tem como retorno qual o `ObjectID` ou seja qual o ID do objeto que acabou de ser criando. 
Já o comando `insert`, tem como diferença que ele é utilizado para uma `array ` de documentos, e tem como retorno um objeto do tipo result.
```js
db.clients.insert([{"name":"Patrick", "age":38},{"name":"Bob Esponja"}]);
```
Esta forma de inserção também e conhecida como `BOOKWRITER`.

Além dos 2 coomandos citados acima, também temos o comando `SAVE`, esse comando básicamente atua da seguinte forma: Caso seja passado nesse comando um documento com um ID já existente ele realizará a atualização, caso não exista nenhum documento com aquele ID, ele realizará a inserção daquele novo documento. 
```js
db.clients.save({"_id": ObjectId("688c1f33a80882f143b0835f"), "name":"Patrick", "age":40})
```
### 5.2 Performance e índices 
Assim como os índices criandos em banco de dados relacionais, no `mongo DB` também há a possíbilidade de criar índices, a analogia mais correta para o que seria um índice em banco de dados, seria como um índice em um livro. 
A única diferença que é valida de se ressaltar a diferença entre a criação é utilização de índices em banco de dados relacionais e no mongo DB é que:  

1. Em banco de dados relacionais, a ultilização/criação de um índice é que este tem como seu objetivo a prevenção de um `TABLE SCAN`
2. No MongoDB, a utilização/criação de um índice é que este tem como objetivo previnir um `Scan Colection`

No mongo db é possível que seja utilizado comandos/scritps em javascript para ciração de collections ou demais dados. Para que possamos realizar a visualização de diferença entre um collection com e sem índices, usareserá utilziado o seguinte comando:  
```js
// Criado um laço de repetição de 1 a 10.000 
// Dentro do laço em questão foi criado um documento simples
// Com o nome e idade com nome e o valor de I e a idade com valor de I
for(var i=0; i<10000; i++){
    db.clients.insert({name: "Cliente" +i, age:i});
}
// Consultando os documentos criados
db.getCollection("clients").find({})
// Contablizando os registros
db.getCollection("clients").count({})
```
De forma automática o MongoDB, já realiza a criação de `ID` para cada documento onde esse ID já vem por padrão com seu índice criado, podemos visualizar tal criação conforme imagem abaixo:  

<table style="text-align: center; width: 100%;"> 
<tr>
    <td style="text-align: center;">
    <img src="imgs/MongoDB_IMGS/indexes_id.png" alt="IndexID" width="50%"/>
    </td>
</tr>
</table>  

Podemos confirmar a busca indexada, realizando a junça de uma busca por um determinado ID, e utilizando do comando `exaplain(true)`, conforme abaixo:
```js
db.getCollection("clients").find({_id: ObjectId("689be94fd5bf7c1012b08412")}).explain(true)
```
Ao executar tal comando podemos visualizar dentro do plano plano de execução estatísticas, da execução da query acima, e possível ver que realizando tal comando que para o plano de execução dessa query foram buscados apenas 1 documento para execução, isso pois o comando ID já possui seu proprio ID
 
<table style="text-align: center; width: 100%;"> 
<tr>
    <td style="text-align: center;">
    <img src="imgs/MongoDB_IMGS/explain_index.png" alt="ExaplainIDX" width="50%"/>
    </td>
</tr>
</table>  

Agora se caso precisarmos realizar a busca por um campo não indexado, como por exemplo o nome?
```js

db.getCollection("clients").find({name: "Cliente0"}).explain(true)

```
<table style="text-align: center; width: 100%;"> 
<tr>
    <td style="text-align: center;">
    <img src="imgs/MongoDB_IMGS/explain_no_Index.png" alt="ExaplainNoIDX" width="50%"/>
    </td>
</tr>
</table>  

Notamos que para realizar essa busca em questão foi executado a busca dessa condição dentro dos __10.000__ documentos, mesmo que na condição tenhamos passado o cliente 0, conforme o script esse sendo o primeiro foi necessário realizar a busca nos documentos. 
Agora para evitar tal collection scan podemos realizar a criação de um index para esse campo, para tal o comando a ser executado é o seguinte 
```js
db.getCollection("clients").createIndex({name: 1},{"name":"idx_name"})
```
Onde para tal comando são necessários 2 parâmetos, sendo o primeiro o nome do campo no qual se deseja criar o index, o segundo o nome do index a ser criado, no primeiro parâmetro foi passado `{name: 1}` para que o index criado fosse de forma ordenada.

Após a criação do index em questão podemos visualizar que ao executar a query de busca por nome, foram examinados apenas 1 documento para tal busca. 

<table style="text-align: center; width: 100%;"> 
<tr>
    <td style="text-align: center;">
    <img src="imgs/MongoDB_IMGS/explain_create_index.png" alt="ExaplainCreateIDX" width="50%"/>
    </td>
</tr>
</table>  

Assim como em banco de dados relacionais, o mongo DB permite diversas formas de realizar a criação de diferentes índices, como índices compostos, para garantir a integridade de um campo etc... 

### 5.3 Agregações

### 5.3.1 Oque é agregação 
Agregação é o procedimento de processar dados em uma ou mais etapas, onde o resultado de cada etapa é utilizado na etapa seguinte, de modo a retornar um resultado combinado.

### 5.3.2 Tipos de agragação
Existem 2 tipos de agregação no Mongo DB
1. Agregação de proposito único 
  - > count
  - > distinct 
  Elas não permitem as customizações das agregações utilizando pipeline.

2. E agregações de pipeline, onde é possível criar diversos tipos de customizações 

### 5.3.2.1 Agregações de proposito único
### 5.3.2.1.1 COUNT
Esse tipo de agregação ao ser executada, irá retornar quantas informações existem, conforme o comando abaixo, 
```js
db.getCollection("clients").count({})
```  
### 5.3.2.1.2 DISTINCT
Esse comando irá retornar todos os valores de forma não duplicada de um determinado campo, então em um cenário onde por exemplo desejamos ver todos os tipos de um determinado campo existentes dentro de uma coleção, para tal utilizamos o comando abaixo:
```js
db.getCollection("clients").distinct({"name"})
```
Após a execução do comando acima podemos verificar uma lista com todos os possíveis valores do campo em questão. 
### 5.3.2.2 Agregações de proposito customizadas ou pipeline
As pipelines mais básicas fornecem "filtros" e "operadores": 
1. Onde nos filtros é possível a realização de "matchs" para "saber" quais serão os dados a serem processados. 
2. Onde nos operados que são as funções que irão manipular os dados  e darão insumo/inputs as proximas etapas. 
São exemplos de operadores o `$group` , `$addFilds` dentre outros.

### 5.3.2.2.1 group
Esse operador é muito últil quando se deseja agrupar os dados de acordo com um determinado campo, mas também é possível realizar sua utilização para contagem dos dados, média aritmética, max, min etc..

<div style="border-left: 4px solid red; background-color:rgb(22, 23, 24); padding: 10px;">
  <strong style="color: red;">IMPORTANTE</strong>
  <p> Como estamos tratando de agregações em <b>pipeline</b>, é possível passar um número "infinito" de processamentos para esse agragador
  então para tal o parâmetro a ser utilizado para o método de agregação em geral será uma <i>array</i>
  </p>
</div>

```js
db.getCollection("restaurants").aggregate([{$group: {_id: "$cusine",total:{$sum:1} }}])
```
Para utilização propriamente dita do comando group, é necessário a passagem de um conjunto de parâmetros, sendo eles
1. O primeiro parâmetro será o ID dele, ou seja o campo em que se deseja realizar a agregação = `_id: "$cusine"`
2. O segundo parâmetro será o acumulador(alguma operação), desejada para esse agrupamento = `total: `{$sum: 1}`

### 5.3.2.2.2 addFields
Essa função é utilizada para adicionar ao resultado um novo campo, sem que seja alterado a collection de origem. 

```js
db.getCollection("restaurants").aggregate([{$addFilds: {"teste":true}}])
```
Assim como realizado no comando [group](#53221-group), o inicio da sintaxe será o mesmo, porém para utilização desse comando é passado 2 parâmetros:
1. Qual será o nome do parâmetro = "teste
2. Qual será o valor desejado para acréscimo de resultado = true

O interessante desse comando e que ao ser utilizado o mesmo não realiza alterações em sua collection, ele apenas realiza a adição de um campo temporário durante a execução daquela agregação, podendo ser utilizado para um proximo passo dessa agregação. 

### 5.3.3 Funções de agregação 

Além dos comando de agregações, existem também as funções sendo elas:  
- `$sum` Realiza a soma de uma determinada condição 
- `$avg` Realiza a média de um determinado campo
- `$max` Retorna o maior valor encontrado de uma determinada operação
- `$min` Retorna o menor valor encontrado de uma determinada operação

### 5.3.3.1 sum
```js
db.getCollection("restaurants").aggregate([{$group: {_id: "$cusine",total:{$sum:1} }}])
```
### 5.3.3.2 max
```js
db.getCollection("restaurants").aggregate([{$group: {_id: "$cusine",total:{$sum:1}, id_maximo:{$max: "restaurant_id"} }}])
```
### 5.3.3.3 min
```js
db.getCollection("restaurants").aggregate([{$group: {_id: "$cusine",total:{$sum:1}, id_maximo:{$min: "restaurant_id"} }}])
```
### 5.3.3.4 avg
```js
db.getCollection("restaurants").aggregate([{$group: {_id: "$cusine",total:{$sum:1}, id_maximo:{$avg: "tam_cusine"} }}])
```

### 5.3.4 Operadores lógicos
Além das funções o MongoDB também conta com os operadores lógicos sendo eles
- `$and` 
- `$or` 
- `$not`
- `$or` 

### 5.3.4.1 Operadores lógicos com filtros
Para melhor exemplificação da utilização de operadores lógicos, também realizaremos a utilização de filtros, para busca, e assim como nos demais comandos visualizados,para realizar tal processo dentro das agregações o parâmetro passado também será uma `array`, porém para utilizar o filtro especificamente a função utilizada será função `match`
```js
db.getCollection("restaurants").aggregate([{$match: {$and:[{cusine: "American"},{borough:"Broklin"}] }}])
```
- Para utilização do operador lógico `and`, o mesmo também irá receber uma array de argumentos, no exemplo assim com auxilio da função `$match` para realizar  o filtro foi passado a função `$and:[{cusine: "American"},{borough:"Broklin"}]` , para determinar que esse match será quando ouver o campo cusine = American & borough =Broklin, fazendo com que sejá retornado ao fim da query, somente os registros que combinarem com a query.   

```js
db.getCollection("restaurants").aggregate([{$match: {$or:[{cusine: "American"},{borough:"Broklin"}] }}])
```
- Para utilização do operador lógico `or`, o mesmo também irá receber uma array de argumentos, no exemplo assim com auxilio da função `$match` para realizar  o filtro foi passado a função `$or:[{cusine: "American"},{borough:"Broklin"}]`, tendo como diferença do comando acima, e que ou ele irá trazer os resultado que condizem com a primeira condição, ou irá trazer resultados que condizem com a segunda condição.

Os demais operadores segem a mesma lógica, porém trocando o comando após o match no caso. 

### 5.3.5 Operadores de comparação
- `>` Maior que. O queivalnte no Mongo é o operador `$gt`
- `<` Menor que. O queivalnte no Mongo é o operador `$lt`
- `<>` Diferente de. O queivalnte no Mongo é o operador `$nte`
- `=` Igual. O queivalnte no Mongo é o operador `$eq`
- `<=` Menor igual. O queivalnte no Mongo é o operador `$lte`
- `>=` Maior igual. O queivalnte no Mongo é o operador `$gte`
---

### Links Uteis
- [EXEMPL](https://github.com/digitalinnovationone/trilha-python-dio)
- [Neo4j Sandbox](https://sandbox.neo4j.com/)
- [Cassandra-try](https://katacoda.com/datastax/courses/cassandra-try-ir-out/try-cql)
- [Redis](https://try.redis.io/)
- [Docker compose docs](https://docs.docker.com/compose/)
- [Docker Hub](https://hub.docker.com)
- [Robo 3T client](https://robomongo.org)
- [Mongodb Cloud](https://cloud.mongodb.com/v2/688ad8be6158e91c31a6d6cc#/overview)
---
As respostas da aula 3 estão [aqui](IMGS)

---
<table style="text-align: center; width: 100%;"> 
<caption><b>Skils do projeto </b></caption>
<tr>
    <td style="text-align: center;">
    <img alt="Markdown" src="https://img.shields.io/badge/markdown-%23000000.svg?style=for-the-badge&logo=markdown&logoColor=white"/>
    </td>
    <td style="text-align: center;">
    <img alt="Python" src="https://img.shields.io/badge/python-3670A0?style=for-the-badge&logo=python&logoColor=ffdd54"/>
    </td>
    <td style="text-align: center;">
    <img alt="VSCode" src="https://img.shields.io/badge/Visual%20Studio%20Code-0078d7.svg?style=for-the-badge&logo=visual-studio-code&logoColor=white"/>
    </td>
<tr> 
</table>

---
Titulo: 3 .Introducao ao MongoDB e Banco de dados NoSQL 

Autor: Thierry Lucas Chaves

Data criacao: 21/07/2025

Data modificacao: 31/07/2025

Versao: 1.0  

---