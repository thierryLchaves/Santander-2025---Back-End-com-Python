# 3 .Introducao ao MongoDB e Banco de dados NoSQL
## Sumário 
- [Introdução ao NoSQL](#1-introdução-ao-nosql)
  - [Apresentação do curso](#11-apresentação-do-curso)
  - [Apresentação](#12-apresentação)
- [Conhecendo tipos do BDNSQL](#2-conhecendo-os-tipos-de-banco-de-dodos-nosql)
  - [Tipos de Nosql](#21-tipos-de-banco-nosql)
  - [Grafos](#22-grafos)
  - [Colunar](#23-coluna-família-de-colunas)
  - [Chave Valor](#24-chave-valor)
  - [Documento](#25-documento)
- [Introdução e Instalação MongoDB](#3-introdução-e-instalação-ao-mongodb)
  - [Introdução MongoDB](#31-introdução-ao-mongodb)
  - [Instalação MOngoDB](#32-instalação)
  - [MongoDB Cloud](#33-mongodb-cloud)
- [Schema Design e B.P](#4-schema-design-e-boas-práticas)
  - [Schema Design](#41-schema-design)
  - [Boas Práticas](#42-boas-práticas)
  - [Json x Bson](#43-json-vs-bson)
- [Conceito na prática](#5-alguns-conceitos-na-prática)
  - [Operações de manipulação](#51-operações-de-manipulação-de-dados)
  - [Performance e índices](#52-performance-e-índices)
  - [Agregações](#52-performance-e-índices)
---
## 1. Introdução ao NOSQL
### 1.1 Apresentação do Curso
__Objetivo do curso__  
Introdução ao mundo do NoSQL, apresentar os tipos de bancos NoSQL assim como realizar pequenas operações em alguns deles com enfase no MongoDB no qual iremos desde sua instalação, opções de uso na nuvem e operações de manipulação de dados.

### 1.2 Apresentação 
#### 1.2.1  Objetivos do curso 
- Entender os fatores que levaram a criação dos bancos NoSQL. 
- Conhecer as principais diferenças gerais entre os BD SQL e NoSQL.
- Conhecer as características e vantagens do uso do BD NoSQL.

<table style="text-align: center; width: 100%;"> 
<tr>
    <td style="text-align: center;">
    <img src="imgs/NEO4J_IMGS/TL_BD.png" alt="time_line_bds" width="50%"/>
    </td>
</tr>
</table>

| | | |
| -- | -- | -- |
| N**ot**  | | **NO** |
| O**nly**| X |
| SQL | | **SQL** |

Diferenças entre BD Relacionais e BD NoSQL  
__Escalabilidade:__  Banco de dados **relacional** Vertical 
- Aumento da capacidade para um único recurso 
- Processador, memoria e disco rígido.
---
__Escalabilidade:__  Banco de dados **relacional** Horizontal 
- Replicas de dados __APENAS PARA LEITURA__    
--- 
__Escalabilidade__ Banco de dadoS **NoSQL** Horizontal 
- Particionando os dados (sharding) entre os nós é o mais conhecido.    

Sendo listado abaixo o maior beneficio da escalabilidade horizontal, presente nos Banco de dados Não relacionais.
1. Maior desempenho na aplicação. (Aperfeiçoando de acordo com a demanda, tendo uma escalabilidade "infinita")

Outra diferença de um BDR(Banco de dados relacional), para um Nosql,se da nos ditos Schemas de um BDR, nesse modelo de banco de dados temos um processo mais engessado, de todo processo conforme imagem abaixo.   

<table style="text-align: center; width: 100%;"> 
<tr>
    <td style="text-align: center;">
    <img src="imgs/NEO4J_IMGS/SchemaDBR.png" alt="Scheamas_DBS" width="50%"/>
    </td>
</tr>
</table>

Já esse processo de Schema não se tem esse processo, podendo ter uma ausência quase que completa desse tipo de  regas de Schemas, ou seja não precisa definir no ato de criação do banco quais serão os tipos de dados a serem aceitos/inseridos naquelas tabelas. 

Outra diferença que aqui pode ser citada, e o caso de performance , em um BDR depende-se inteiramente da performance do tipo de disco que aquele banco está "alocado", em um Nosql ele dependerá mais do tamanho do cluster e da latência de rede.
No que se refere as diferenças de transações, segue a lista de comparativos 

| |Transações | |
| -- | -- | -- |
| BD Relacional | | BD NoSQL |
| **A**tomicidade | | **Ba**sically Available |
| **C**onsistência | | **S**oft-State |
| **I**solamento | | **E**ventually Consistent |
| **D**urabilidade | |  |

Das características e vantagens, são elas:
- Flexibilidade
- Escalabilidade
- Alta performance.

---
## 2. Conhecendo os tipos de banco de dodos NoSQL
### 2.1 Tipos de banco Nosql
<table style="text-align: center; width: 100%;"> 
<tr>
    <td style="text-align: center;">
    <img src="imgs/NEO4J_IMGS/ranking_dbs.png" alt="ranking_nosql_grafos" width="50%"/>
    </td>
</tr>
<tr>
    <td style="text-align: center;">
    <img src="imgs/NEO4J_IMGS/tipos_NOSQL.png" alt="tipos_bancos_nosql" width="50%"/>
    </td>
</tr>
</table>

### 2.2 Grafos
<table style="text-align: center; width: 100%;"> 
<tr>
    <td style="text-align: center;">
    <img src="imgs/NEO4J_IMGS/banco_tipo_grafos.png" alt="BANCO_DO_TIPO_GRAFOS" width="50%"/>
    </td>
</tr>
</table>

Grafos basicamente são estruturas matemáticas, que são compostas de nós e seus vértices, ao se abstrair isso para o mundo do banco de dados temos os nós que serão como os nossos dados, e os vértices serão os relacionamentos. Nesse modelo é muito comum para detecção de fraudes, mecanismos de recomendações, redes sociais, sistemas de arquivos, jogos etc... ao se consultas no ranking de banco de dados olhando para os banco do tipo de grafos temos o `Neo4j` como top 1 dos mais utilizados. 
Para a prática desse tipo de banco de dados iremos criar uma estrutura de registros que compões os dados de uma rede social utilizando um `sandbox do Neo4J`. É valido ressaltar que o `Neo4J` é um dos poucos banco de dados NoSQL que aplica as propriedades `ACID`,para além de também ter um bom desempenho no quesito de concorrência de transação, e outro ponto que é valido ressaltar, e que sua linguagem é conhecida como Cypher. 
Para tal processo foi utilizado um [sandbox do Neo4j](https://sandbox.neo4j.com/)   
Dentro do banco de dados foi criado uma label conforme comando abaixo. 
```cypher
CREATE(:Client {name: "Bob Esponja", age: 28, hobbies:['Caçar agua-viva','Comer hamburgueres']})
```
Após a criação desse label/nó podemos utilizar o comando de `match`que seria uma especie de select para o Neo4j, conforme abaixo:
```cypher
match (bob_espoja) return bob_espoja
```
O comando abaixo, demonstrar algumas características do Neo4j, sendo um banco de dados NoSQL, o Neo4j aplica também o conceito de Schema-free, ou seja não é necessário realizar o insert de todos os dados para algum nó mesmo que esse aplique-se a um label. Outro ponto , que podemos ver é que é possível também já aplicar o relacionamento entre nós com utilização de labels, e isso poderá ser feito diretamente no ato da criação de um nó, no comando abaixo, criamos um nó para cliente, e mais um para adicionar um relacionamento entre cliente e bloqueado que no caso esta sendo apontado tal relacionamento com `-[]->`, após o fechamento do `()` do primeiro nó
```cypher
CREATE (:Client{name:"Lula Molusco", age:30, hobbies:['Tocar clarinete']}) -[:Bloqueado]->(:Client{name:'Patrick Estela', hobbies:['Caçar agua-viva']})
```
Ao realizar o `MATCH`, podemos visualizar de forma gráfica os relacionamentos e nós existentes no banco
<table style="text-align: center; width: 100%;"> 
<tr>
    <td style="text-align: center;">
    <img src="imgs/NEO4J_IMGS/nos_Neo4j.png" alt="Nos_Neo4j" width="50%"/>
    </td>
</tr>
</table>

Já para criar um relacionamento entre nós já existentes podemos realizar o seguinte comando, seguindo a estrutura MATCH (*A variável na qual é desejado a atribuição do Match*), similarmente a um processo de atribuição de variável. 
```cypher
MATCH (bob:Client{name:"Bob Esponja"}), (patrick:Client{name:'Patrick Estela'}) CREATE (bob)-[:Amigo]->(patrick)
```
O comando acima listado, obedece a seguinte estrutura. No bloco do `Match` estamos criando duas *"variáveis"* bob e patrick  e realizando a busca com o MATCH, no label de cliente nós que tenham em sua propriedade `name` os nomes, Bob Esponja e Patrick Estrela, após a busca e atribuição de variáveis com esse bloco, estamos criando um relacionamento entre elas com o bloco `CREATE` , onde estamos dizendo que bob é amigo de patrick, a relação de direcionamento é definida através do sentido da *"seta"* `< >` onde nesse caso exemplificado estou aponto de bob para patrick `->`.  
Agora para exclusão de um relacionamentos podemos utilizar a seguinte sintaxe:
```cypher
MATCH (patrick:Client{name:'Lula Molusco'})-[relacionamento:Bloqueado]->() DELETE relacionamento
```
Assim como foi realizado para criar um novo relacionamento a partir de um já existente, foi realizado também para a deleção de um relacionamento a utilização de um `Match`, porém o restante do comando diverge, após a busca e atribuição vemos que temos a abertura de um processo de relacionamento, seguido de uma variável e qual é a label utilizada,  e posteriormente qual será esse relacionamento apagado, onde informamos através de no nó anonimo `()`, que serão apagados todos os relacionamentos que tenham essa label, em seguida o comando recebe o comando DELETE e o que quero deletar que no caso é que existe para variável nomeada de relacionamento.  
Já para exclusão de um nó podemos, utilizar a mesma estrutura do comando para apagar o relacionamento, porém se a adição das condições de relacionamento conforme exemplo abaixo:
```cypher
MATCH (lula:Client{name:"Lula Molusco"}) DELETE lula
```
Já para atualizar um dado, propriedades para um nó existente, seguimos a ideia de atualização com base no retorno de um `MATCH`, porém a diferenciação do delete ou create o comando para atualizar algo em um nó é SET, após esse comando utilizamos a variável encontrada, e dizemos o que dentro da estrutura por exemplo do label o que vamos atualizar. 
```cypher
MATCH (patrick:Client {name:'Patrick Estela'}) SET patrick.age = 23;
```
Ainda na linha de atualização também podemos atualizar um label, para tal ao invés de atribuir a variável uma nova propriedade dentro de uma  label já existente , inserimos a sintaxe `SET variavel:Nome da nova label`.

---
### 2.3 Coluna-Família de colunas
<table style="text-align: center; width: 100%;"> 
<tr>
    <td style="text-align: center;">
    <img src="imgs/Cassandra_IMGS/NOSQL_COLUNA.png" alt="columns_nosq" width="50%"/>
    </td>
</tr>
</table>

Os banco de dados colunares tem uma forma de armazenamento diferente, ao contrário dos banco de dados relacionais tradicionais, que armazenam seus dados em uma única tabela, no bancos de dado NoSQL baseados em colunas, o seu armazenamento é realizado conforme o próprio nome sugere, em suas colunas, com suas informações diferentes entre elas.   
Já no banco de dados colunares um ponto que se é valido ressaltar a diferença trata-se da **hierarquia**, a sua distribuição e armazenamento e feito dentro do que é chamado de `keyspace`, dentro desse keyspace teremos uma família de colunas, sendo essa dita família de colunas similar ao que são as tabelas em banco de dados relacionais. ou seja dentro de cada keyspace teremos as informações agregadas em colunas, porém a coluna em si diferentemente do banco de dados relacional, não é constituída apenas do valor, essa coluna é constituída de 3 informações:
1. Chave da coluna, 
2. O valor da coluna. 
3. E o timestamp  
Outro ponto que é valido se ressaltar, e que em um banco de dados do tipo coluna, somente será armazenado em memoria algo que tenha informação.   

<table style="text-align: center; width: 100%;"> 
<tr>
    <td style="text-align: center;">
    <img src="imgs/Cassandra_IMGS/ranking_dbs_colunas.png" alt="Rankings_column_database" width="50%"/>
    </td>
</tr>
</table> 

Durante o estudo utilizaremos o banco de dados `Cassandra`, e é valido ressaltar que sua utilização e recomenda em cenários que temos um volume de leitura maior do que o de escrita, e seu uso tido como adequado e quando se tem a necessidade de realizar as consultas através da chave-primária.
#### 2.3.1 Diferenças terminológicas 
- __Keyspace:__ Agrupamento de famílias de colunas => Databases.
- __Column Family/Table:__ Agrupamento de colunas => table.
- __Row key:__ Chave que representa uma linha de coluna => Primary Key.
- __Column:__ Representa um valor contendo: Name, Value e Timestamp.  
- __Registro de transações:__  Compras, resultados de testes, filmes assistidos e localização mais recente do filme. Rastreando praticamente qualquer coisa, incluindo status do pedido de pacotes etc..
Outro ponto a ser considerado durante a utilização do banco de dados `Cassandra`, e que ele é um banco com ausência total de transações, e isso deve ser levado em consideração para sua escolha.   
Para se criar um `keyspace` utilizamos o seguinte comando. 
```cql
CREATE KEYSPACE NAME_KEYSPACE WITH replication = {'class': 'SimpleStrategy', 'replication_factory' : 1};
```
Conforme demonstrado no comando acima, diferentemente da criação de um `DATABASE` em um banco de dados SQL, no cassandra precisamos além das palavras reservadas, CREATE KEYSPACE, também temos que passar como instrução alguns argumentos de replicação daquele keyspace, através do trecho `WITH replication`, onde após tal comando passamos alguns valores com notação Json, no exemplo supracitado, passamos qual a classe que esse keyspace pertence, e posteriormente o fator de replicação. 
Para utilizar esse keyspace criado assim como em um banco SQL, utilizamos o comando:  
```cql
USE NAME_KEYSPACE
```



### 2.4 Chave-valor
### 2.5 Documento
--- 
## 3. Introdução e Instalação ao MongoDB
### 3.1 Introdução ao MongoDB
### 3.2 Instalação
### 3.3 MongoDB Cloud

---
## 4. Schema Design e Boas práticas
### 4.1 Schema Design 
### 4.2 Boas práticas
### 4.3 Json vs Bson
---
## 5. Alguns conceitos na prática
### 5.1 Operações de manipulação de dados
### 5.2 Performance e índices 
### 5.3 Agregações


### Links Uteis
- [EXEMPL](https://github.com/digitalinnovationone/trilha-python-dio)
- [Neo4j Sandbox](https://sandbox.neo4j.com/)
- [Cassandra-try](https://katacoda.com/datastax/courses/cassandra-try-ir-out/try-cql)

---
As respostas da aula 3 estão [aqui](IMGS)

tabela exemplo 
| | |
| -- | -- |
| nome | valor |

<div style="border-left: 4px solid red; background-color:rgb(22, 23, 24); padding: 10px;">
  <strong style="color: red;">Exemplo de alerta</strong>
  <p> Somente um exemplo.</p>
</div>

exemplo código 
```
print("Hello World!")
```
---
<table style="text-align: center; width: 100%;"> 
<caption><b>Skils do projeto </b></caption>
<tr>
    <td style="text-align: center;">
    <img alt="Markdown" src="https://img.shields.io/badge/markdown-%23000000.svg?style=for-the-badge&logo=markdown&logoColor=white"/>
    </td>
    <td style="text-align: center;">
    <img alt="Python" src="https://img.shields.io/badge/python-3670A0?style=for-the-badge&logo=python&logoColor=ffdd54"/>
    </td>
    <td style="text-align: center;">
    <img alt="VSCode" src="https://img.shields.io/badge/Visual%20Studio%20Code-0078d7.svg?style=for-the-badge&logo=visual-studio-code&logoColor=white"/>
    </td>
<tr> 
</table>

---
Titulo: 3 .Introducao ao MongoDB e Banco de dados NoSQL 

Autor: Thierry Lucas Chaves

Data criacao: 21/07/2025

Data modificacao: 26/07/2025

Versao: 1.0  

---