# 4 .Explorando Banco de dados relacionais com Python DB API
## Sumário 
- [Intro Banco de dados Relacional](#1-introdução-aos-bancos-de-dados-relacionais)
  - [PT.1](#11-introdução-aos-bancos-de-dados-relacionais--pt1)
  - [PT.2](#12-introdução-aos-bancos-de-dados-relacionais--pt2)
  - [PT.3](#13-introdução-aos-bancos-de-dados-relacionais--pt3)
- [Python DB API](#2-python-db-api)
- [Criando uma tabela](#3-criando-uma-tabela)
- [Inserindo registros](#4-inserindo-registros)
- [Atualizando registros](#5-atualização-de-registros)
- [Removendo registros](#6-removendo-registros)
- [Inserindo registros em lote](#7-inserindo-registros-em-lote)
- [Consultando registros](#8-consultando-os-registros)
  - [Consulta com único registro](#81-consultas-com-único-resultado)
  - [Consulta com múltiplos registros](#82-consultas-com-múltiplos-resultados)
- [Alterando Row factory](#9-alterando-o-row_factory)
- [Boas Práticas](#10-boas-práticas)
  - [Introdução as boas práticas](#101-introdução)
  - [Pensando em segurança](#102-pensando-em-segurança)
- [Gerenciando Transações](#11-gerenciando-transações)
---
## 1. Introdução aos Bancos de Dados Relacionais 
### Objetivo Geral 
Vamos abordar os conceitos básicos de banco de dados como podemos interagir com eles usando a __DB API__ em Python  

<div style="border-left: 4px solid red; background-color:rgb(22, 23, 24); padding: 10px;">
  <strong style="color: red;"> Observação </strong>
  <p> A supracitada <b>DB API </b>, é a especificação, ou seja parte do python que irá determinar como a linguagem deverá se portar ao realizar comunicação entre um determinado SGBD</p>
</div> 

#### O que é um banco de dados?
Os bancos de dados são coleções organizadas de dados, geralmente armazenados e acessados eletronicamente a partir de um sistema de computador.   
#### Tipos de bancos de dados
Existem vários tipos de banco de dados, incluindo relacionais, não relacionais, orientados a objetos e muito mais. O tipo mais comum é o banco de dados relacional, que organiza os dados em tabelas. 
#### Qual o papel do SGBD
Os sistemas de gerenciamento de banco de dados (SGBD) são softwares que interagem com o usuário, outras aplicações e o próprio banco de dados para capturar e analisar os dados. Existem muitos SGBDS disponíveis no mercado, alguns dos mais populares incluem: __MySQL, PostgreSQL, SQLite, Oracle Database, Microsoft SQL Server e Maria DB__.   

### 1.1 Introdução aos Bancos de Dados Relacionais -PT1
Um banco de dados relacional é um tipo de banco de dados que organiza os dados em tabelas. Cada tabela é composta de linhas, que representam registros individuais, e colunas, que representam campos de dados. 
#### Tabelas 
Em um banco de dados relacional, uma tabela é uma estrutura que organiza os dados em linhas e colunas, semelhante a uma planilha. 
Cada linha representa um registro distinto e cada coluna representa um tipo de informação, chamado de campo. Por exemplo, uma tabela *'CLIENTES'* pode ter campos como _'ID', 'NOME', 'EMAIL' e 'TELEFONE'_. 
#### Chaves - primárias 
Cada tabela em um banco de dados relacional deve ter uma chave primária. A chave primária é uma coluna (ou conjunto de colunas) cujo valor é único para cada registro. Isso garante que cada registro na tabela possa ser identificado de maneira única. Por exemplo, na tabela 'CLIENTES', o campo 'ID' pode ser a chave primária. 
### 1.2 Introdução aos Bancos de Dados Relacionais -PT2
#### Chaves - Estrangeiras 
Por exemplo, em uma tabela 'PEDIDOS', podemos ter um campo 'ClienteID' que seja uma chave estrangeira apontando para a chave primária da tabela 'CLIENTES'. Isso cria um relacionamento entre 'Pedidos' e 'Clientes', permitindo que cada pedido seja associado a um cliente específico. 
#### Relacionamento entre tabelas
Os bancos de dados relacionais permitem estabelecer relações entre tabelas. As relações podem ser __'um para um', 'um para muitos', ou 'muitos para muitos'.__ Estas relações permitem efetuar consultas complexas que unem dados de várias tabelas. 

### 1.3 Introdução aos Bancos de Dados Relacionais -PT3
#### SQL (Structured Query Language)
O SQL é a linguagem usada para interagir com banco de dados relacionais. Com SQL, podemos criar tabelas, inserir, atualizar e deletar registros bem como executar consultas para buscar dados.

```sql
-- Cria um novo banco de dados
CREATE DATABASE loja;

-- Cria uma tabela para armazenar informações de produtos
CREATE TABLE produtos (id INTEGER PRIMARY KEY AUTOINCREMENT, nome VARCHAR(100),preco DECIMAL);

-- Inclui um novo produto
INSERT INTO produtos (nome, preco) VALUES ('Curso Python', 250.00);

-- Lista os produtos
SELECT * FROM produtos;

-- Atualiza o produto com ID informado
UPDATE produtos SET nome='Curso de Python para iniciantes' WHERE id = 1 ;

-- Exclui o produto com ID informado
DELETE FROM produtos WHERE id = 1;
```

---
## 2. Python DB API
#### Conectando-se a um Banco de dados
A primeira etapa para trabalhar com um banco de dados é estabelecer uma conexão. Vamos ver como podemos fazer isso usando Python DB API. 
A DB API é uma especificação, que irá determinar como o `python` irá se comunicar com SGBD.  
Existe um driver responsável por realizar tal conexão, no curso em questão será demonstrado apenas sobre o "conector" do SQLITE, porém os comandos funcionam para os demais SGBDS, devendo apenas se atentar para qual SGBD está sendo trabalhado. Abaixo segue um exemplo de comando padrão para estabelecer uma conexão com banco de dados. 
```py
# No exemplo abaixo demonstra uma conexão com SQLITE3
import sqlite3

con = sqlite3.connect('meu_banco_de_dados.db')
```
Acima descrevemos um modo de conexão com SGBD `SQLITE`, porém para melhor exemplificação segue abaixo o modelo de conexão com SGBD `postresql`  
```py
import psycopg 

conn = pyscopg2.connect(DNS)

with conn:
  with conn.cursor() as curs:
    curs.execute(SQLI1)

with conn:
    with conn.cursor() as curs:
      curs.execute(SQLI2)

# Sair do contexto não fecha a conexão automaticamente 
conn.close()

```

<div style="border-left: 4px solid red; background-color:rgb(22, 23, 24); padding: 10px;">
  <strong style="color: red;"> Observação </strong>
  <p> Ao realizar qualquer tipo de conexão com um SGBD, é de suma importância que haja o banco de dados em questão já instalado previamente na máquina. </p>
</div> 

Outro exemplo de conexão com SGBD, seria do mysql, conforme exemplo abaixo:
```py
import mysql.connector

mybd = mysql.connector..connect(
  host = "localhost"
  user = "yourusername"
  password = "yourpassword"
)

print(mybd)
```
Nos 3 exemplo citados podemos verificar um padrão de abertura de conexão, sendo mais especifico para este caso o método `connect`, esse método é o responsável por determinar onde iniciar a conexão com SGDB, graças a Python DB API, esse métodos se repetem é são aplicáveis para os diversos SGBDS 

--- 
## 3. Criando uma tabela
Após a criação do banco de dados com o método informado, podemos dar seguimento ao processo e realizar o processo de criar tabelas para tal banco de dados anteriormente criado.  
Para realizar tal processo podemos seguir os seguintes comandos. 

```py
cur = conn.cursor()

cur.execute("CREATE TABLE name_table(atrib_1, atrib_2,atrib_3)")
```
Acima verificamos 2 métodos, necessários para realizar comandos dentro do Python para criar ou manipular informações dentro de um banco de dados. 
Já na primeira linha verificamos a instância de um objeto chamado de `cursor()`, esse cursor é o objeto que precisa ser instanciado, para que se possa realizar executar comando dentro do banco de dados. 
OU seja a primeira linha do código acima o método `cursor()`, realiza a instância de um objeto responsável por realizar comandos para o banco já o método `execute()`, é responsável por realizar comandos do banco,o execute é um método do objeto cursor()

--- 
## 4. Inserindo registros
Inserir registros em um banco de dados é uma operação comum. Com a Python DB API, usamos a operação INSERT do SQL para isso. Conforme demonstrado abaixo:
```py
data = (4,'abcd')
cursor.execute('INSERT INTO minha_tabela VALUES (?,?)',data)
conn.commit()
```
Conforme demonstrado no exemplo acima, essa é uma maneira de realizar um comando de inserção em uma tabela dentro de um banco de dados, porém exite outra maneira de realizar o mesmo comando sendo ele:
```py 
nome = 'thierry'
email = 'thierry@gmail.com'
curs.execute(f"INSERT INTO cliente (nome,email) values('{nome}','{email}')")
```
A maneira a cima também funcionaria porém a mesma sem problemas, porém o comando em questão está sujeito a venerabilidades, como por exemplo a de `SQL INJECTION`, essa técnica consiste em realizar comandos mascarados dentro de outros comandos. Para evitar tais problemas usamos então o modo descrito primeiramente, que também é conhecido como comandos preparados, onde é caracterizado pela DB API, pelo caractere `?`, esses caracteres denotam que serão passados uma tupla de parâmetros para sua substituição.


<div style="border-left: 4px solid red; background-color:rgb(22, 23, 24); padding: 10px;">
  <strong style="color: red;"> IMPORTANTE </strong>
  <p> Quando estamos trabalhando com a DB API em Python, podemos notar que o objeto denominado de cursor, é o responsável por realizar múltiplas operações 
  no contexto de um banco de dados, e diferentemente de software para trabalhar com um SGBD, esse cursor não é auto-commit, pois um mesmo cursor pode realizar
  enumeras operações, então para se manter um contexto de uma transação e sempre importante que após esse processo seja realizado o commit.
   </p>
</div> 

--- 
## 5. Atualização de registros 
A operação UPDATE do sql é usada para modificar registros existentes. é importante ser específico ao usar o UPDATE para evitar alterar mais registros do que o planejado. Conforme demonstrado abaixo:  
```py 
data = (4,'abcd')
cursor.execute('UPDATE minha_tabela SET name = ? where id = ?', data)
conn.commit()
```
Assim como realizado no processo de inserção de registro também deve-se priorizar a utilização de comando preparados, através do caractere `?` e assim como no processo de inserção de informação também utilizaremos método commit da conexão. 

---
## 6. Removendo registros
A operação DELETE do SQL é usada para remover registros. Novamente, precisamos ser específicos ao usar o DELETE para evitar remover mais registros do que o planejado. Conforme demonstrado abaixo:

```py
id = 4 
cursor.execute('DELETE FROM minha_tabela WHERE id = ?',(id,))
conn.commit()
```

--- 
## 7. Inserindo registros em lote
Operações em lote são úteis quando precisamos inserir muitos registros de uma vez. Com Python DB API, podemos usar o método `executemany()` para isso.  Conforme demonstrado abaixo:
```py 
data = [(5,'abcde'),(6,'abcdef'),(7,'abcdefg')]
cursor.executemany('INSERT INTO minha_tabela VALUES(?,?)',data)
conn.commit()
``` 
A vantagem primordial do método `executemany()`, se da ao custo operacional envolvido para operação, se pensarmos seria possível realizar a mesma inserção com um laço de repetição, para inserir os __N__ registros desejados, porém ao analisar um comando dessa maneira o que o programa faria seria chamar o método de `execute` da biblioteca escolhida, e posteriormente o `commit()`, para cada inserção/atualização/deleção de informação, o que gastaria recurso operacional desnecessários. Ao utilizar-se desse comando o mesmo realiza a inserção de uma fez ou seja em uma única transação.

--- 
## 8. Consultando os registros
### 8.1 Consultas com único resultado 
O método `fetchone()` pode ser usado para recuperar um único registro de resultado., Ele retorna o próximo registro na lista de resultados ou `None` se não houver mais resultados. Conforme demonstrado abaixo:

```py
cursor.execute('SELECT * FROM minha_tabela WHERE id = 1')
result = cursor.fetchone()
print(result)
```
### 8.2 Consultas com múltiplos resultados
O método `fetchall()` pode ser usado para recuperar todos os registros de resultados de uma vez. Ele retorna uma lista de registros ou uma lista vazia se não houver mais resultados.  Conforme demonstrado abaixo:

```py
cursor.execute('SELECT * FROM minha_tabela)
result = cursor.fetchall()
for row in results:
  print(row)
```
--- 
## 9. Alterando o row_factory
Os resultados das consultas são retornados como tuplas por padrão. Se a tupla não atender as nossas necessidades podemos usar a classe `sqlite3.ROW` ou uma `row_factory` customizada.  Conforme demonstrado abaixo:

```py
cursor.row_factory = sqlite3.ROW
cursor.execute('SELECT * FROM minha_tabela WHERE id = 1')
result = cursor.fetchone()
print(dict(result))
```
A vantagem primordial da utilização de uma row_factory, podemos dizer, que como sua implementação nos retorna um dicionário além da legibilidade de código, a mesma irá nos garantir que independente da ordem dos resultados, sempre acessaremos o valor desejado, pois como o processo descrito acima transforma o resultado que por padrão era uma tupla, em um dicionário, ao  realizar essa conversão podemos obter o valor de um determinado campo que seria o equivalente da coluna da tabela desejada como a chave do valor, ou seja se quisermos acessar o valor ou os valores de um determinado campo ao saber o nome da coluna, podemos acessar aquele ou aqueles valores específicos  da coluna desejada assim como acessamos valores de um dicionário em Python. Ex:..
```py
cliente = recuperar_cliente(conexao=conn, cursor=cur, id=3)
print(dict(cliente))
print(cliente["id"], cliente["nome"], cliente["email"])
```

--- 
## 10. Boas práticas
### 10.1 Introdução
Ao escrever consultas SQL em Python, é importante seguir boas práticas para garantir a segurança e a eficiência do seu código.  
### 10.2 Pensando em segurança
Uma dessas práticas é evitar a concatenação de strings nas consultas e usar consultas parametrizadas. Isso não apenas melhora a legibilidade do código, mas também ajuda a prevenir ataques de Injeção SQL. Conforme demonstrado abaixo:  

```py 
# evite fazer isso 
id = 1
cursor.execute("SELECT * FROM minha_tabela where id = "+str(id))

# prefira fazer isso 
id = 1 
cursor.execute("SELECT * FROM minha_tabela where id = ?",(id,))
```

--- 
## 11. Gerenciando transações
A DB API também nos permite gerenciar transações, o que é crucial para manter a integridade dos dados.  Conforme demonstrado abaixo:
```py
try:
  cursor.execute("INSERT INTO minha_tabela VALUES (?,?)",(1,'abcd'))
  conn.commit()
except Exception as e:
  print(f"Ocorreu um erro: {e}")
  conn.rollback()
```
<div style="border-left: 4px solid red; background-color:rgb(22, 23, 24); padding: 10px;">
  <strong style="color: red;"> IMPORTANTE </strong>
  <p> Quando tratamos do contexto de transações, e importante se atentar para ordem da execução dos comandos, 
  no exemplo acima estamos tratando apenas uma modificação dentro do bloco de try/except, porém em um contexto de múltiplas modificações, 
  no caso de realizar a chamado do commit a cada modificação o mesmo somente irá tratar da linha de erro da modificação, o que em alguns 
  cenários pode nos ocasionar problemas para além de performance, então e sempre ideal que nesse contexto de transações a comando de commit, 
  somente seja executado ao final das operações.
   </p>
</div> 

--- 
### Links Uteis
- [EXEMPL](https://github.com/digitalinnovationone/trilha-python-dio)

---
As respostas da aula 4 estão [aqui](IMGS)

---
<table style="text-align: center; width: 100%;"> 
<caption><b>Skils do projeto </b></caption>
<tr>
    <td style="text-align: center;">
    <img alt="Markdown" src="https://img.shields.io/badge/markdown-%23000000.svg?style=for-the-badge&logo=markdown&logoColor=white"/>
    </td>
    <td style="text-align: center;">
    <img alt="Python" src="https://img.shields.io/badge/python-3670A0?style=for-the-badge&logo=python&logoColor=ffdd54"/>
    </td>
    <td style="text-align: center;">
    <img alt="VSCode" src="https://img.shields.io/badge/Visual%20Studio%20Code-0078d7.svg?style=for-the-badge&logo=visual-studio-code&logoColor=white"/>
    </td>
<tr> 
</table>

---
Titulo: 4 .Explorando Banco de dados relacionais com Python DB API 

Autor: Thierry Lucas Chaves

Data criacao: 21/07/2025

Data modificacao: 21/08/2025

Versao: 1.0  

---